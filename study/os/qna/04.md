**질문**
<!-- 무조건 공백 -->
인터럽트가 무엇인지 그리고 인터럽트의 2가지 종류에 대해서 간단하게 설명하세요.
<!-- 무조건 공백 -->
<details>
<summary><b>정답</b></summary>
<!-- summary 아래 한칸 공백 두어야함 -->
<!-- 무조건 한칸 공백 아래에 두고 정답 입력 -->

CPU가 수행중인 작업은 방해를 받아 잠시 중단될 수 있는데, 이렇게 CPU의 작업을 방해하는 신호를 인터럽트(interrupt)라고 합니다.

동기 인터럽트(synchronous interrupts)는 CPU에 의해 발생하는 인터럽트입니다. CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때, 가령 CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트가 동기 인터럽트입니다. 이런 점에서 동기 인터럽트는 예외(exception)라고 부릅니다.

비동기 인터럽트(asynchronous interrupts)는 주로 입출력장치에 의해 발생하는 인터럽트입니다. 일반적으로 비동기 인터럽트를 인터럽트라 칭하기도 합니다.
</details>

<br>

**질문**
<!-- 무조건 공백 -->
비동기 인터럽트의 처리 순서에 대해서 간단히 설명하세요.
<!-- 무조건 공백 -->
<details>
<summary><b>정답</b></summary>
<!-- summary 아래 한칸 공백 두어야함 -->
<!-- 무조건 한칸 공백 아래에 두고 정답 입력 -->

1. 입출력장치는 CPU에 인터럽트 요청 신호를 보냅니다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인합니다.
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인합니다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업합니다.
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행합니다.
6. 인터럽트 서비스 루틴 실행이 끝나면 (4)에서 백업해 둔 작업을 복구하여 실행을 재개합니다.

</details>

<br>

**질문**
<!-- 무조건 공백 -->
CPU가 명령어들을 하나씩 실행한다는 가정하에,  한 개의 명령어를 실행하는데 필요한 전체 처리 과정이 무엇인지 말하고
그 과정을 단순하게 2단계로 나눠서 설명해주세요 (추가적으로 설명할 단계가 있으면 설명해주셔도 됩니다) 
<!-- 무조건 공백 -->
<details>
<summary><b>정답</b></summary>
<!-- summary 아래 한칸 공백 두어야함 -->
<!-- 무조건 한칸 공백 아래에 두고 정답 입력 -->

하나의 명령어를 처리하는 정형화된 흐름을 [명령어 사이클] 이라고 합니다.  
명령어 사이클을 단순하게 2 단계로 나눠서 설명하면 [명령어 인출]과 [명령어 실행] 단계가 있습니다.  
[명령어 인출]은 명령어를 메모리에서 CPU로 가져오는 단계이고 [명령어 실행]은 CPU로 가져온 명령어를 실행하는 단계입니다.  
(명령어 실행은 명령어 해독+데이터 인출 ~ 데이터 저장)  
여기서 추가적인 단계들을 설명하자면 명령어를 인출하여 CPU로 가져와도 바로 명령어를 실행할 수 없고, 명령어를 실행하기 위해  
메모리에 접근을 한 번 더 해야 하는데, 이것을 [간접 사이클]이라고 합니다.   
또한, 프로그램 실행 중 CPU의 현재 처리 순서를 중단 시키고 다른 동작을 수행하도록 하는 사이클인 [인터럽트 사이클]이 있습니다.  

</details>

<br>

**질문**
<!-- 무조건 공백 -->
위 질문에서 이어지는데, 명령어 인출 과정과 명령어 실행 과정에는 레지스터가 필요합니다.
이때,  어떤 레지스터들이 있고 무슨 역할을 맡는지 설명해주세요 (책에 나온 레지스터들)
<!-- 무조건 공백 -->
<details>
<summary><b>정답</b></summary>
<!-- summary 아래 한칸 공백 두어야함 -->
<!-- 무조건 한칸 공백 아래에 두고 정답 입력 -->

[프로그램 카운터] - 다음에 인출할 명령어의 주소를 가지고 있는 레지스터

[명령어 레지스터] - 가장 최근에 인출된 명령어 코드가 저장되는 레지스터

[기억장치 주소 레지스터(MAR)] - 프로그램 카운터에 저장된 명령어 주소가 시스템 버스로 출력되기 전에 일시적으로 저장되는 주소 레지스터
이 레지스터는 시스템 주소 버스와 직접적으로 연결되어 있는 인터페이스

[기억장치 버퍼 레지스터(MBR)] - 메모리에 쓰여질 데이터 또는 메모리로부터 읽혀진 데이터들을 일시적으로 저장하는 버퍼 레지스터
명령어도 저장 가능

여기서 추가적으로 [누산기]로 데이터를 일시적으로 저장하는 레지스터입니다. (초기 데이터, 중간 결과, 최종결과 저장)
레지스터의 길이는 CPU가 한 번에 처리할 수 있는 데이터 비트 수(1 word)와 동일합니다.

</details>

<br>

**질문**
<!-- 무조건 공백 -->
인터럽트라는 것이 무엇이고, 이를 통해 얻을 수 있는 효과는 무엇인지 간단하게 설명해주세요.
<!-- 무조건 공백 -->
<details>
<summary><b>정답</b></summary>
<!-- summary 아래 한칸 공백 두어야함 -->
<!-- 무조건 한칸 공백 아래에 두고 정답 입력 -->

기존의 CPU가 수행중인 일의 흐름을 멈추도록 신호를 보내 수행중인 작업을 중단하는 것을 말합니다.
일단, 기본적으로 인터럽트를 이용하면 CPU의 처리율을 향상시킵니다. 왜냐하면 입출력 장치들은 CPU에 비해 훨씬 느립니다.
그래서 입출력 연산이 진행되는 동안 CPU는 다른 명령어를 수행시킬 수 있습니다. 
</details>

<br>

**질문** 
<!-- 무조건 공백 -->
ALU가 연산의 결과값을 바로 메모리에 저장하지 않고 레지스터에 저장하는 이유는 무엇인가요?
<!-- 무조건 공백 -->
<details>
<summary><b>정답</b></summary>
<!-- summary 아래 한칸 공백 두어야함 -->
<!-- 무조건 한칸 공백 아래에 두고 정답 입력 -->

연산의 결과값이 반드시 메모리에 저장되는 것도 아니고, 
메모리는 레지스터에 비해 접근 속도가 느리기 때문에 레지스터에 저장하는 것이 훨씬 효율적입니다.
</details>
