**질문** 
<!-- 무조건 공백 -->
인덱스란?
<!-- 무조건 공백 -->
<details>
<summary><b>정답</b></summary>
<!-- summary 아래 한칸 공백 두어야함 -->
<!-- 무조건 한칸 공백 아래에 두고 정답 입력 -->

인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.
</details>

<br>

**질문** 
<!-- 무조건 공백 -->
인덱스의 장점과 단점
<!-- 무조건 공백 -->
<details>
<summary><b>정답</b></summary>
<!-- summary 아래 한칸 공백 두어야함 -->
<!-- 무조건 한칸 공백 아래에 두고 정답 입력 -->

[장점]
인덱스의 가장 큰 특징은 데이터들이 정렬이 되어있다는 점이다.

1. 조건 검색 Where 절의 효율성
테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽으로 저장된다. 이렇게 되면 Where절에 특정 조건에 맞는 데이터들을 찾아낼때도 레코드의 처음부터 끝까지 다 읽어서 검색 조건과 맞는지 비교해야 한다. 이것을 풀 테이블 스캔 (Full Table Scan)이라고 함. 하지만 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾아낼 수 있다. 이것이 인덱스(Index)를 사용하는 가장 큰 이유. 

2. 정렬 Order by 절의 효율성
인덱스(Index)를 사용하면 Order by에 의한 Sort과정을 피할수가 있다. Order by는 굉장히 부하가 많이 걸리는 작업이다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가적으로 발생된다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 된다. 이미 정렬이 되어 있기 때문에 가져오기만 하면 됨.

3. MIN, MAX의 효율적인 처리가 가능하다.
이것 또한 데이터가 정렬되어 있기에 얻을 수 있는 장점이다. MIN값과 MAX값을 레코드의 시작값과 끝 값 한건씩만 가져오면 되기에 FULL TABE SCAN으로 테이블을 다 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있다.
 

[단점]
인덱스의 가장 큰 문제점은 정렬된 상태를 계속 유지 시켜줘야 한다는 점이다.

1. INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀐다면 INDEX 테이블 내에 있는 값들을 다시 정렬을 해야함.

2. 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.

만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다. 앞에서 설명한대로, UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다고 하였다. 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다. 
</details>

<br>

**질문** 
<!-- 무조건 공백 -->
인덱스를 사용하면 좋은 경우
<!-- 무조건 공백 -->
<details>
<summary><b>정답</b></summary>
<!-- summary 아래 한칸 공백 두어야함 -->
<!-- 무조건 한칸 공백 아래에 두고 정답 입력 -->

규모가 작지 않은 테이블
INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
데이터의 중복도가 낮은 컬럼
</details>

<br>

**질문** 
<!-- 무조건 공백 -->
인덱스 자료구조로 헤시테이블 보다 b+tree가 더 적합한 이유
<!-- 무조건 공백 -->
<details>
<summary><b>정답</b></summary>
<!-- summary 아래 한칸 공백 두어야함 -->
<!-- 무조건 한칸 공백 아래에 두고 정답 입력 -->

해시 테이블은 (Key : 컬럼의 값, Value : 데이터의 위치)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다. 이러한 이유로 데이터베이스의 인덱스에서는 B+Tree가 일반적으로 사용된다.
B+Tree는 오직 leaf node에만 데이터를 저장하고 leaf node가 아닌 node에서는 자식 포인터만 저장한다. 그리고 leaf node끼리는 Linked list로 연결되어있다. 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생할 수 있다. 따라서 B+Tree의 Linked list를 이용하면 순차 검색을 효율적으로 할 수 있게 된다.
</details>


<br>

**질문** 
<!-- 무조건 공백 -->
Hash 인덱스가 무엇인지 설명해주세요
<!-- 무조건 공백 -->
<details>
<summary><b>정답</b></summary>
<!-- summary 아래 한칸 공백 두어야함 -->
<!-- 무조건 한칸 공백 아래에 두고 정답 입력 -->

- 해시 인덱스는 key에 대한 hash function을 통해 얻을 수 있는 index입니다.
- Index entry들이 bucket이라는 단위로 저장됩니다.
- Bucket이라는 것을 할당하는 방법에는
    - static hashing : bucket을 고정된 수로 할당
    - dynamic hashing : 데이터 양에 따라 가변적으로 bucket을 늘려나감
    
    요러케 두가지가 있습니다~~!
</details>